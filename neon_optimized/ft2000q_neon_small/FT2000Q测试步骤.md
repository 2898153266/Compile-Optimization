# FT2000Q 平台测试步骤

## 问题修复说明

✅ **已修复**：Makefile中的递归调用死循环问题
- 原因：`benchmark_O0` 目标与构建规则冲突，导致无限递归
- 解决：将目标重命名为 `build_O0/O1/O2/O3`

---

## 快速测试流程

### 1. 上传文件到FT2000Q

将整个 `ft2000q_new_test` 目录上传到FT2000Q服务器：

```bash
# 在本地Windows上（假设已配置SSH）
scp -r ft2000q_new_test user@ft2000q-server:/path/to/test/
```

### 2. 登录FT2000Q并进入目录

```bash
ssh user@ft2000q-server
cd /path/to/test/ft2000q_new_test
```

### 3. 清理旧文件（如果有）

```bash
make clean_all
```

### 4. 编译测试

#### 选项A：编译单个优化级别

```bash
# 编译 O0 版本
make build_O0

# 编译 O1 版本
make build_O1

# 编译 O2 版本
make build_O2
```

#### 选项B：编译所有优化级别（推荐）

```bash
make all_opt
```

预期输出：
```
编译 O0 版本...
编译完成！
运行命令: ./benchmark_O0
编译 O1 版本...
编译完成！
运行命令: ./benchmark_O1
编译 O2 版本...
编译完成！
运行命令: ./benchmark_O2
所有优化级别编译完成！
-rwxr-xr-x 1 user user 123K Oct 28 10:00 benchmark_O0
-rwxr-xr-x 1 user user 118K Oct 28 10:00 benchmark_O1
-rwxr-xr-x 1 user user 115K Oct 28 10:00 benchmark_O2
```

### 5. 运行性能测试

#### 选项A：手动运行各个版本

```bash
# 测试 O0 优化级别
echo "=== 测试 O0 ===" | tee results_O0.txt
./benchmark_O0 | tee -a results_O0.txt
cp benchmark_results.csv benchmark_results_O0.csv

# 测试 O1 优化级别
echo "=== 测试 O1 ===" | tee results_O1.txt
./benchmark_O1 | tee -a results_O1.txt
cp benchmark_results.csv benchmark_results_O1.csv

# 测试 O2 优化级别
echo "=== 测试 O2 ===" | tee results_O2.txt
./benchmark_O2 | tee -a results_O2.txt
cp benchmark_results.csv benchmark_results_O2.csv
```

#### 选项B：使用自动化脚本（推荐）

```bash
# 编译并运行所有优化级别
make test_all
```

或使用shell脚本：

```bash
bash test_all_opt.sh
```

### 6. 查看结果

```bash
# 查看文本结果
cat results_O0.txt
cat results_O1.txt
cat results_O2.txt

# 查看CSV数据
ls -lh benchmark_results_O*.csv
```

### 7. 下载结果到本地

```bash
# 在本地Windows上执行
scp user@ft2000q-server:/path/to/test/ft2000q_new_test/benchmark_results_O*.csv ./
scp user@ft2000q-server:/path/to/test/ft2000q_new_test/results_O*.txt ./
```

---

## 测试内容说明

本次测试包含：

### 优化版本（3个）
1. **dgemm_naive** - 朴素三重循环实现
2. **dgemm_unroll** - 循环展开优化
3. **dgemm_neon** - NEON SIMD优化

### 编译优化级别（3个）
- **O0**: 无编译器优化
- **O1**: 基础编译器优化
- **O2**: 高级编译器优化

### 测试矩阵规模（9个）
- 16×16, 32×32, 64×64
- 128×128, 256×256, 512×512
- 1024×1024, 2048×2048, 4096×4096

### 测试指标
- 执行时间（毫秒）
- GFLOPS性能
- 相对加速比（相对于naive实现）

---

## 预期结果

### O0 优化级别
- naive: 基准性能
- unroll: 1.5-2.0x 加速
- neon: 2.0-3.0x 加速

### O1 优化级别
- naive: 比O0快1.5-2x
- unroll: 2.0-3.0x 加速（相对于O1 naive）
- neon: 3.0-4.0x 加速

### O2 优化级别
- naive: 比O0快2-3x
- unroll: 2.5-3.5x 加速（相对于O2 naive）
- neon: 4.0-6.0x 加速

---

## 故障排除

### 如果编译失败

```bash
# 检查编译器版本
gcc --version

# 应该支持 ARMv8 和 NEON
gcc -march=armv8-a -dM -E - < /dev/null | grep -i arm
gcc -march=armv8-a -dM -E - < /dev/null | grep -i neon
```

### 如果make还是报warning

Makefile第67行的warning是因为之前有两个目标定义冲突，现在已经修复。如果还有warning：

```bash
# 确保使用更新后的Makefile
head -70 Makefile | tail -5
# 应该看到 build_O0 而不是 benchmark_O0
```

### 如果性能异常

```bash
# 检查CPU频率
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq

# 设置性能模式（如果有权限）
sudo cpupower frequency-set -g performance
```

---

## Python结果比较（可选）

如果FT2000Q上有Python3：

```bash
# 比较O1和O2的性能差异
python3 compare_results.py benchmark_results_O1.csv benchmark_results_O2.csv

# 或者下载到本地比较
```

---

## Makefile可用命令

```bash
make help          # 查看所有可用命令
make info          # 查看编译配置信息
make clean         # 清理当前优化级别文件
make clean_all     # 清理所有文件
make build_O1      # 只编译O1版本
make all_opt       # 编译O0/O1/O2所有版本
make test_all      # 编译并测试所有版本
```

---

## 预计测试时间

- 编译时间：每个优化级别约 10-30 秒
- 运行时间：每个优化级别约 2-5 分钟
- **总计**：约 15-20 分钟完成全部测试

---

## 注意事项

1. 确保FT2000Q有足够的内存（至少2GB可用）
2. 4096×4096矩阵测试需要约384MB内存
3. 建议在系统负载较低时进行测试
4. 如果测试过程中系统变慢，可以减小矩阵规模（修改benchmark.c中的SIZE数组）

---

## 联系与支持

如有问题，请检查：
- benchmark.c 中的测试配置
- Makefile 中的编译选项
- README.md 中的详细说明

